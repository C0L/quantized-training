syntax = "proto3";

package codegen;

message Memory {
  int32 partition = 1;
  uint64 address = 2;
}

message Tensor {
  string node = 1;           // Associated node name (for debugging)
  repeated int32 shape = 2;  // Shape of the tensor
  string dtype = 3;          // Data type (e.g., "float32", "int8")
  optional Memory memory = 4; // Optional memory info
  optional float scale = 5;  // Optional scale for quantization
  optional OpOverload reshape = 6; // Optional fused reshape/slicing
}

// Wrapper for repeated tensors (since `oneof` doesn't allow repeated fields)
message TensorList {
  repeated Tensor tensors = 1;
}

// Wrapper for repeated integers (to avoid `repeated int32` inside `oneof`)
message IntList {
  repeated int64 values = 1;
}

// Represents arguments for operations
message Argument {
  oneof arg_type {
    Tensor tensor = 1;
    TensorList tensor_list = 2;
    IntList int_list = 3;
    int64 int_value = 4;      
    float float_value = 5;
    bool bool_value = 6;
    string str_value = 7;
  }
}

// Represents an operation, without fusion information
message OpOverload {
  string name = 1;            // Unique name of the node
  string op = 2;              // Type of operation (e.g., call_function, call_module)
  string target = 3;          // Target function/module name
  repeated Argument args = 4; // Positional arguments
  map<string, Argument> kwargs = 5; // Keyword arguments
}

// Represents a fused operation
message OpOverloadList {
  string name = 1;
  repeated OpOverload op_list = 2;
}

message Operation {
  oneof op_type {
    OpOverload op = 2;
    OpOverloadList fused_op = 3;
  }
  oneof return_type {
    Tensor output = 4;
    TensorList outputs = 5;
  }
}

// Represents a torch.fx.Graph
message Model {
  repeated Tensor inputs = 1;
  repeated Tensor parameters = 2;
  repeated Operation ops = 3;
}
